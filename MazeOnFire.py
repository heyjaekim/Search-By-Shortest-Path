"""MazeRunner_Part4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17DijHhKtkAxJhVz6iL2Z9XYeawUajGlu

## Question-4

### Maze on fire
"""

# Import libraries

import numpy as np
import random as rand
import math
#import matplotlib.pyplot as plt
import seaborn as sns
import math
import queue as Q
import time
import pprint as pp
import pandas as pd
from operator import itemgetter
import queue
try:
    import simplegui
except ImportError:
    import SimpleGUICS2Pygame.simpleguics2pygame as simplegui



FRAME_WIDTH = 700
def generate_maze(size, prob):
    
  rows = size
  cols = size
  mat = np.ones((size,size))

  for i in range(rows):
      for j in range(cols):
          if( rand.uniform(0,1) < prob ):     # if random number is greater than p, an obstacle is added to the cell (i, j)
              mat[i][j] = 0
  
  mat[0][0] = 1              # start needs to be unblocked
  mat[size-1][size-1] = 1    # goal needs to be unblocked
  return mat 

# Function to obtain the length of a path

def path_length(prev_list, start, goal):
    
    prev_node = goal
    path = [prev_node]
    path_len = 0
    
    if bool(prev_list):
        while(prev_node in prev_list.keys() and prev_list[prev_node] != start):
            current_node = prev_node
            prev_node = prev_list[(current_node)]
            path.append(prev_node)
        
        path.append(prev_list[prev_node])
        path.reverse()

        path_len = len(path)
    
    return path_len, path

# Function to prioritize children based on the distance to the goal. This improves DFS search

def prioritize_children(maze, goal, visited, x, y):
  
    children = []
    node = []
    h = []
    
    node.append((x+1, y))
    h.append((goal - node[0][0]) + (goal - node[0][1]))
    
    node.append((x, y+1))
    h.append((goal - node[1][0]) + (goal - node[1][1]))
    
    node.append((x-1, y))
    h.append((goal - node[2][0]) + (goal - node[2][1]))
    
    node.append((x, y-1))
    h.append((goal - node[3][0]) + (goal - node[3][1]))
    
    for i in range(4):
        ind = h.index(min(h))
        h.pop(ind)
        current_child = node.pop(ind)
        if(check_child_validity(maze,current_child,visited)):
            children.append(current_child)
    
    children.reverse()
    return children

# Improved function of Depth-First Search

def improved_DFS(maze, start, goal):
  
    fringe = [start]
    visited = [start]
    prev_list = {}    # To store pointers from children to their parents. It is useful for backtracking the path
    
    count_of_nodes = 0
    max_fringe_size = 0
    
    while fringe:
        (i, j) = fringe.pop()
        count_of_nodes+=1
        max_fringe_size = max( max_fringe_size, len(fringe) )
        
        if (i, j) == goal:    # to check if the goal state is found
            return 1, prev_list, count_of_nodes, max_fringe_size
           
        # Generating and adding child nodes in fringe 
        children = prioritize_children(maze,goal[0]-1,visited,i,j)    #----> Improvement
        if children:
          for c in children:
            prev_list[c] = (i,j)
            fringe.append(c)
            visited.append(c)
     
    return 0, prev_list, count_of_nodes, max_fringe_size  # No path found

# Function to assign heuristics to nodes

def findHeuristic(goalCell, cell, heuristic):
        (x1, y1) = cell
        (x2, y2) = goalCell
        if heuristic == "euclidean":
            return math.sqrt((x1 - x2) ** 2 + (y1 - y2) ** 2)
        elif heuristic == "manhattan":
            return abs(x1 - x2) + abs(y1 - y2)

# Function for A* search

def render_path(goalCell, pathDict):
        # Build a path (list) from a dictionary of parent cell -> child cell
        current = pathDict[goalCell]
        path = []
        while current != (0, 0):
            path += (current,)
            current = pathDict[current]
        return path[::-1]

def in_bounds(cell):
        # Check if a cell is in the map
        x = cell[0]
        y = cell[1]
        return (0 <= x < dim) and (0 <= y < dim)

def neighborCells(cell):

        x = cell[0]
        y = cell[1]
        neighborCells = set()
        DIRS = [(x, y + 1), (x + 1, y), (x, y - 1), (x - 1, y)]
        for (i, j) in DIRS:
            if in_bounds((i, j)):
                if maze[i, j] == 0:
                    neighborCells.add((i, j))
        return neighborCells

def A_star(maze, startCell, goalCell, heuristic):
    
  dim = maze.shape[0]
  
  priorityQ = queue.PriorityQueue()
  parentCellSet = {}
  mincost = {}
  cellsVisited = set()
  maxFringe = 0

  priorityQ.put((0, startCell))
  mincost[startCell] = 0
  cellsVisited.add(startCell)
  path = []
  while not priorityQ.empty():
      cell = priorityQ.get()  # referring to the curernt cell
      cell = cell[1]
      maxFringe = max(maxFringe, priorityQ.qsize())

      if cell == goalCell:
          path = render_path(goalCell, parentCellSet)
          return 1, path, len(cellsVisited), maxFringe, cellsVisited

      for dir in neighborCells(cell):
          newCost = mincost[cell] + 1
          # or new_cost < cost_so_far[next_cell]:
          if dir not in cellsVisited:
              mincost[dir] = newCost
              parentCellSet[dir] = cell
              cellsVisited.add(dir)

              priority = newCost + findHeuristic(goalCell, dir, heuristic)
              priorityQ.put((priority, dir))
  return 0, path, len(cellsVisited), maxFringe, cellsVisited
    

def create_child_nodes(maze,visited,x,y):
  child_list = []
  
  node1 = (x+1,y)   # Right neighbor
  if(check_child_validity(maze,node1, visited)):
    child_list.append(node1)
                
  node2 = (x,y+1)   # Bottom neighbor
  if(check_child_validity(maze,node2, visited)):
    child_list.append(node2)

  node3 = (x-1,y)   # Left neighbor
  if(check_child_validity(maze,node3, visited)):
    child_list.append(node3)

  node4 = (x,y-1)   # Top neighbor
  if(check_child_validity(maze,node4, visited)):
    child_list.append(node4)
  
  return child_list

def check_child_validity(maze,vertex,visited):
    
    dim = maze.shape[0] 
    
    # If dimensions are in the range of the matrix dimensions (if cell is going out of bounds)
    if vertex[0]==-1 or vertex[1]==-1 or vertex[0]==dim or vertex[1]==dim:
        return False
      
    # If cell is closed or already visited
    elif maze[vertex[0],vertex[1]]==0 or vertex in visited:
        return False
    
    # Valid
    else:
        return True

"""### Fire generation"""

# Function to generate neighbors of a cell for fire.

def generate_neighbours(cell):
  
  neighbours = []
  
  i = cell[0]
  j = cell[1]
  
  if( i+1 < dim  ):
    neighbours.append((i+1,j))
  
  if( i-1 >= 0):
    neighbours.append((i-1,j))
    
  if( j+1 < dim ):
    neighbours.append((i,j+1))
    
  if( j-1 >= 0 ):
    neighbours.append((i,j-1))
  
  return neighbours


"""Function to determine the average success rate of this strategy as a function of q (flammibility rate)."""

# Function to check the success rate of the baseline condition

def success_rate(dim, p, n_trials):
  
    probability_solvable = []
    
    for q in range(0, 11, 1):

        q = q/10.0
        success = 0
        
        for i in range(n_trials):
          
          output = baseline(dim,p,q)
          
          if(output == 1):
            success = success + 1    # Count the number of succesfully solved mazes
          else :
            continue
            
        probability_solvable.append(success/n_trials)
        print("Success for q = " + str(q) + " is " + str(success))

    print(probability_solvable)
    x = np.arange(0,1.1,0.1)
   
    plt.clf()
    plt.cla()
    plt.close()
    
    plt.bar(x, probability_solvable, width = 0.05 )
    
    plt.xlabel("q")
    plt.ylabel("Probability of success")
    plt.title("Density vs solvability for dim = " + str(dim) + ", #trials = "+ str(n_trials))
    plt.xticks(x)
    plt.show()
'''
dim = 50
p = 0.3
start = (0,0)
goal = (dim - 1, dim - 1)
fire_start = (0,dim-1)
fire_goal = (dim-1,0)
success_rate(dim, p, 50)
'''
"""##Fire Runner"""

# Function to check whether a given child is on fire. Returns boolean

def check_child_safety(maze,vertex,visited):
    
    dim = maze.shape[0] 
    
    # If dimensions are in the range of the matrix dimensions (if cell is going out of bounds)
    if vertex[0]==-1 or vertex[1]==-1 or vertex[0]==dim or vertex[1]==dim:
        return False
      
    # If cell is on fire
    elif maze[vertex[0],vertex[1]]==-1:
        return False
    
    # Valid
    else:
        return True

# Function to prioritize children based on the number of neighbors on fire. This helps the fire runner.

def safe_children(maze, visited, x, y):
  
    children = []
    nodes = []
    n = []
    
    node = ((x+1, y))
    neighbors = [(x+1,y+1), (x+2,y), (x+1,y-1)]
    if(check_child_validity(maze, node, visited)):
      n.append(0)
      for i in neighbors:
        if check_child_safety(maze, i, visited):
          n[len(n)-1] += 1
        n[len(n)-1] = (dim - 1 - node[0]) + (dim - 1 - node[1]) - n[len(n)-1]    # Priority consider Manhattan distance to the goal and the number of neighbors on fire
      nodes.append(node)
    
    node = ((x, y+1))
    neighbors = [(x+1,y+1), (x,y+2), (x-1,y+1)]
    if(check_child_validity(maze, node, visited)):
      n.append(0)
      for i in neighbors:
        if check_child_safety(maze, i, visited):
          n[len(n)-1] += 1
      n[len(n)-1] = (dim - 1 - node[0]) + (dim - 1 - node[1]) - n[len(n)-1]
      nodes.append(node)
    
    node = ((x-1, y))
    neighbors = [(x-1,y+1), (x-2,y), (x-1,y-1)]
    if(check_child_validity(maze, node, visited)):
      n.append(0)
      for i in neighbors:
        if check_child_safety(maze, i, visited):
          n[len(n)-1] += 1
      n[len(n)-1] = (dim - 1 - node[0]) + (dim - 1 - node[1]) - n[len(n)-1]
      nodes.append(node)
    
    node = ((x, y-1))
    neighbors = [(x+1,y-1), (x,y-2), (x-1,y-1)]
    if(check_child_validity(maze, node, visited)):
      n.append(0)
      for i in neighbors:
        if check_child_safety(maze, i, visited):
          n[len(n)-1] += 1
      n[len(n)-1] = (dim - 1 - node[0]) + (dim - 1 - node[1]) - n[len(n)-1]
      nodes.append(node)
          
    for i in range(len(n)):
        ind = n.index(min(n))
        n.pop(ind)
        current_child = nodes.pop(ind)
        children.append(current_child)
    
    
    children.reverse()
    return children

# Function to prioritize children based on the distance to the goal and distance from fire. This improves the strategy of fire runner.

def save_children(maze, visited, x, y, fire_cells):
  
    children = []
    nodes = []
    h = []
    
    dist = []
    node = ((x+1, y))
    if(check_child_validity(maze, node, visited)):
      for i in fire_cells:
        dist.append((abs(i[0]-node[0]) + abs(i[1]-node[1])))    # Manhattan distance to the goal
      min_dist = 0
      if dist:
        min_dist = min(dist)
      h.append( (dim - node[0]) + (dim - node[1]) - min_dist)    # Factoring in the minimum distance from the fire
      nodes.append(node)
    
    dist = []
    node = ((x, y+1))
    if(check_child_validity(maze, node, visited)):
      for i in fire_cells:
        dist.append(abs(i[0]-node[0]) + abs(i[1]-node[1]))
      min_dist = 0
      if dist:
        min_dist = min(dist)
      h.append( (dim - node[0]) + (dim - node[1]) - min_dist)
      nodes.append(node)
    
    dist = []
    node = ((x-1, y))
    if(check_child_validity(maze, node, visited)):
      for i in fire_cells:
        dist.append(abs(i[0]-node[0]) + abs(i[1]-node[1]))
      min_dist = 0
      if dist:
        min_dist = min(dist)
      h.append( (dim - node[0]) + (dim - node[1]) - min_dist)
      nodes.append(node)
    
    dist = []
    node = ((x, y-1))
    if(check_child_validity(maze, node, visited)):
      for i in fire_cells:
        dist.append(abs(i[0]-node[0]) + abs(i[1]-node[1]))
      min_dist = 0

    
    for i in range(len(h)):
        ind = h.index(min(h))
        h.pop(ind)
        current_child = nodes.pop(ind)
        children.append(current_child)
    
    
    children.reverse()
    return children

# Function to implement search to stay away from all fire cells.

def fire_cell_search(maze, start, goal, fire_start, fire_goal, q):

  print("here fire cell search")
  fringe = [start]
  visited = [start]
  prev_list = {}    # To store pointers from children to their parents. It is useful for backtracking the path

  count_of_nodes = 0
  max_fringe_size = 0
  
  maze[0][dim-1] = -1 # Intial condition - fire on upper right corner
  
  fire_fringe = []
  fire_fringe.append((0, dim-1))
  not_on_fire_fringe = []
  new_fire = []
  fire_cells = [(0, dim-1)]
  
  while fringe:
      maze_temp = maze*100
      (i, j) = fringe.pop()
      #display_path(maze_temp, prev_list, start, (i,j))
      
      # Termination Conditions
      
      if goal in fire_cells:    # Goal is on fire
        print("goal is on fire")
        return 3, (i,j), prev_list, count_of_nodes, max_fringe_size, fire_cells
      
      if (i,j) in fire_cells:    # Runner location is on fire
        print("runner location is on fire")
        return 2, (i,j), prev_list, count_of_nodes, max_fringe_size, fire_cells
      
      count_of_nodes+=1
      max_fringe_size = max( max_fringe_size, len(fringe) )

      if (i, j) == goal:    # to check if the goal state is found
          return 1, goal, prev_list, count_of_nodes, max_fringe_size, fire_cells

      # Generating and adding child nodes in fringe 
      children = save_children(maze,visited,i,j,fire_fringe)    #----> Improved DFS
      if children:
        for c in children:
          prev_list[c] = (i,j)
          fringe.append(c)
          visited.append(c)
      
      # Adding neighbors to the fringe
      if (fire_fringe):
        while fire_fringe:
          neighbours = generate_neighbours(fire_fringe.pop())
          
          while neighbours:
            neighbor = neighbours.pop()
            if maze[neighbor] != -100 and maze[neighbor] != 0 and neighbor not in not_on_fire_fringe:
              not_on_fire_fringe.append(neighbor)

      not_on_fire_fringe_temp = not_on_fire_fringe.copy()
      while not_on_fire_fringe_temp :
          k = 0
          cell = not_on_fire_fringe_temp.pop()
          neighbours = generate_neighbours(cell)

          for v in neighbours:  
            if (maze[v] == -1):
              k = k+1

          probability = 1 - pow(1-q, k)
          if( rand.uniform(0,1) < probability):  ##If the cell catches fire
            new_fire.append(cell) 
            not_on_fire_fringe.remove(cell)
      
      while new_fire:
        n = new_fire.pop()
        fire_fringe.append(n)
        maze[n] = -1
        fire_cells.append(n)

  print("here fire cell search stops here")        
  return 0, (i,j), prev_list, count_of_nodes, max_fringe_size, fire_cells

start_time = time.time()

dim = 100
p = 0.2
q = 0.3
start = (0,0)
goal = (dim - 1, dim - 1)
fire_start = (0,dim-1)
fire_goal = (dim-1,0)

is_goal_reached = 0
is_fire_reached = 0

maze = generate_maze(dim, p)
while is_goal_reached != 0 or is_fire_reached != 0:
  is_goal_reached, prev_list_path, count_of_nodes_path, max_fringe_size_path, visited_path = A_star(maze, start, goal , "manhattan")
  is_fire_reached, prev_list_fire, count_of_nodes_fire, max_fringe_size_fire, visited_fire = A_star(maze, fire_start, fire_goal, "manhattan")
  if is_goal_reached != 0 or is_fire_reached != 0:
    maze= generate_maze(dim, p)

is_reached, runner_location, prev_list, count_of_nodes, max_fringe_size, fire_cells = fire_cell_search(maze, start, goal, fire_start, fire_goal, q)
print("Time taken: " + str(time.time()-start_time))
#maze_temp = maze*100

def visualize_maze(a_map, fireCells, path):
  width = FRAME_WIDTH / dim
  for x in range(0, dim):
      for y in range(0, dim):
          points = [(x * width, y * width), ((x + 1) * width, y * width),
                      ((x + 1) * width, (y + 1) * width), ((x * width), (y + 1) * width)]
          
          if (x, y) in fireCells:
              a_map.draw_polygon(points, 1, "Black", "#FFAA00")
          if(x, y) == start or (x, y) == goal:
              a_map.draw_polygon(points, 1, "Black", "#00FF00")
          elif (x, y) in path:
              a_map.draw_polygon(points, 1, "Black", "#F540FF")
          elif maze[x][y] == 0:
              a_map.draw_polygon(points, 1, "Black", "#464646")
          else:
              a_map.draw_polygon(points, 1, "Black", "White")

def generate_map(maze):
  visualize_maze(maze,[],[])

def draw_path_fire_1():
  visualize_maze(maze, fire_cells, prev_list)


#Frame and UI
frame = simplegui.create_frame('Maze is on fire', FRAME_WIDTH, FRAME_WIDTH)
frame.set_draw_handler(generate_map)
#frame.add_button("Generate Strategy One", generate_map, 100)
frame.add_label("")
frame.add_label("")
frame.add_label("Size: "+ str(dim) +"\n"+ "Probability: " + str(p) +"\n" + "q-value: " + str(q))

#Algorithms
frame.add_button("Maze On Fire Strategy 1", draw_path_fire_1, 150)

frame.start()

